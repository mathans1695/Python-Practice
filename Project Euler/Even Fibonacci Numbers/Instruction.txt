Problem Statement from Project Euler:
	Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

				1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

	By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
	
Problem Statement:
	Find the sum of even Fibonacci numbers from 0 to 4 million
		ie.) sum of n Fibonacci numbers, such that 2 < n < 4000000
		Also consider first and second value as 1 and 2
		
	Input:
		First line will contain an integer which represents n, we have to find the sum of even Fibonacci number upto n
		
	Output:
		Print the sum
		
Brute Force Approach:
	
	Thought Process:
		First of all, we have to find list of all fibonacci numbers upto n, first and second value is given
		
		First = 1 and Second = 2
		Adding first and second will give sum = 3
		
		Then, we have to add the second and sum to get the fourth number in fibonacci series, but before doing that assign the second to first, second to sum and fourth number will result in adding again first and second with the reassigned value. It is illustrated below:
			sum = first + second
			first = second
			second = sum
			
		By iterating through every number upto n, the sum will have the sum of n fibonacci number. In order to find even sum, we have to omit the odd numbers from sum during iteration itself.
		
		Simplest solution is to add the sum to result, if the sum is divisible by 2, for every iteration:
			result = 2
			if sum % 2 == 0:
				result += sum
				
		By iterating upto n, the result will hold the sum of even Fibonacci numbers
		
	Algorithm:
		1. Initialize First = 1, second = 2, sum = 0, result = 2
		2. Iterate from 2 to n using for loop:
			for i in range(2, n):
		3. Perform the operation:
			sum = first + second
			first = second
			second = sum
			if sum % 2 == 0:
				result += sum
		4. print the result
			print(result)
			
	Implementation:
		first, second, result, sum = 1, 2, 2, 0
		for i in range(2, n):
			sum = first + second
			first = second
			second = sum
			if sum % 2 == 0:
				result += sum
		print(result)
		
	Asymptotic Analysis:
		The for loop will run n-2 times, because we are starting from 2 to n. We are considering all the other operations as contant time O(1) operations. So, the complexity of this problem is O(n-2).
			Ex. If n = 10, for loop will execute 8 times, so the complexity is O(8)
			If n = 4000000, for loop will execute 3999998 times, so the complexity is O(3999998)
				Consider a processor which executes 10000 instrution per second, to perform the above problem for 4000000 as n will require 400 seconds(6.67mins). So, we have to wait approximately 7 minutes to get the result. But todays computers can able to perform Gigahertz of instruction per second(10^6 instruction per second) and there are even processor used in bitcoin mining that can perform terahertz of instruction per second(10^12 instruction/second)
				
			For finding a sum of even n fibonacci numbers of 4000000 will take 7 minutes, what happens if we are about to find the sum of 4000000000000 number(4 * 10^12), will take 400000000 seconds(4620 days - 12 years) to get the result.
				But if you 10^12 processor, you will get the result in 4 seconds. If you use Gigahertz processor, you will get the result in 46 days
				
Another Approah:
	Thought Process:
		Is there a way to skip the iteration, no. We can't skip the iteration, because a fibonacci number is the result of previous two number. My mind only have limited knowledge, so I can't able to reduce the complexity below n-2.
		
		But one small changes can be made, which will not reduce the complexity. See any pattern occurs in the below first 10 fibonacci series:
			1, 2, 3, 5, 8, 13, 21, 34, 55, 89,......
			O, E, O, O, E, O , O , E , O , O ,...... Where O - Odd, E - Even
		
		After the first two numbers,for every three numbers, there is 2 odd numbers and one even number. Take the if statement inside the for loop, we have implemented in the previous approach, that checks for even number.
		Instead of checking, whether a number is even or not. In the 3rd, 6th, 9th, 12th, 15th,.... the number is even. So, we can use if i % 3 == 0, add it to the result. We are checking, the particular iteration is multiples of 3, if so add the fibonacci number to the sum
		
	Algorithm:
		1. Same algorithm as previous approach, instead of sum % 2 == 0, use i % 3 == 0
		
	Implementation:
		first, second, result, sum = 1, 2, 2, 0
		for i in range(2, n):
			sum = first + second
			first = second
			second = sum
			if i % 3 == 0:
				result += sum
		print(result) 
		
	Asymptotic Analysis:
		1. Same as previous approach, because it has to iterate from 2 to n. Complexity is O(n-2), which is approximately equal to O(n) - Linear Complexity
		
	Modification:
		The for loop runs from 2 to n(Exclusively), ie.) during 1st iteration i = 2, sum = 3 and result = 2
			2nd iteration, i = 3, sum = 5 & result = 7 - because the condition i % 3 == 0 satisfied
			3rd iteration, i = 4, sum = 8 & result = 7
			4th iteration, i = 5, sum = 13 & result = 7
			5th iteration, i = 6, sum = 21 & result = 28 - satisfies the condition i % 3 == 0
			.
			.
			.
			till n
		
		Modify the for loop like for i in range(1, n-1), to make sure it runs n-2 times. ie.) for n = 10, this loop will run from 1 to 9(Exclusively) = 8 times
		On 1st iteration, i = 1,
		   2nd iteration, i = 2,
		   3rd iteration, i = 3, satisfies the condition i % 3 == 0, then sum will be added to the result
		   4th iteration, i = 4,
		   5th iteration, i = 5,
		   6th iteration, i = 6, sum will be added to the result
		   .
		   .
		   .
		   till n-1
		   
	Algorithm:
		Change the for loop range from 1 to n-1
		
	Implementation:
		first, second, result, sum = 1, 2, 2, 0
		for i in range(2, n):
			sum = first + second
			first = second
			second = sum
			if i % 3 == 0:
				result += sum
		print(result)
		
	Asymptotic Analysis:
		Still the same as previous problem, because it runs n-2 times. The complexity is O(n)
		
	Note: While executing approach 2, I got the wrong result. That's why I modify this approach. In the middle of thought process, you should not try to run the implementation and change your thought process. After you idea generation over, you should run the program and if you got the wrong result, modify the result
		
		
Another Approach:
	Thought Process:
		Consider we are having an array that has series of fibonacci number upto n. By reading the array, we can compute the sum of even numbers. 
		Ex.) array =  1, 2, 3, 5, 8, 13, 21, 34, 55, 89 for n = 10
		              0, 1, 2, 3, 4, 5 , 6 , 7 , 8 , 9 
					  
			By starting our iteration from 1 to n, in step of 3 will get us even numbers in the fibonacci series
				ie) sum = 0
					for i in range(1, n, 3):
						sum += array[i]
						
	Algorithm:
		1. We have to store the series of fibonacci numbers upto n into an array
		2. Iterate through the array using for loop from 1 to n in step of 3
		3. Add the even fibonacci number to array
		
	Implementation:
		first, second, result, sum = 1, 2, 0, 0
		array = [1, 2]
		for i in range(2, n):
			sum = first + second
			first = second
			second = sum
			array.append(sum)
			
		for i in range(1, n, 3):
			result += array[i]
		print(result)
		
	Asymptotic Analysis:
		We are using two for loops, one iterates from 2 to n and has complexity of O(n-2)- approximately equal to O(n) and second one iterates from 1 to n in multiples of 3 - it takes (n-1)/3 iteration and has complexity of O((n-1)/3)
		
		Ex.) If n = 10, first for loop runs 8 times and second for loop runs 3 times((10-1)/3)
		
		As you can see the second for loop runs thrice as fast as first one
		
		Eventhough, the linear complexity reduced thrice. The array occupies some space in memory. In the first two approach, the space required to compute the sum is less compared to this approach.
		
		Ex.) Consider 10 fibonacci numbers stored in the array, in python it is called list. Single element in the list occupies (4*32 bits)128 bits of memory. So, for 10 elements, the list occupies 1280 bits(160 bytes) of memory
		What if the array has to hold 100 fibonacci numbers, that would take 1.5625 Kilobytes(Kb)
		if 1000 numbers - 15.625 Kilobytes
		   10000 numbers - 156.25 Kilobytes
		   100000 numbers - 1.525 Megabytes
		   1000000 numbers - 15.25 Megabytes
		   10000000 numbers - 152.5 Megabytes
		
		Did you see the 10 million numbers will take 152.5 MBs memory and it is only an approximation, considering only 128 bits for each number, but a real fibonacci number will take up more than 128 bits of memory each.
		Ex.) If n = 100, the result will be 286573922006908542050 - 21 digits. Even a 64 bit computer can store upto 2^64 numbers, that is 20 digits, to store this number we require more than 64 bit, next hope is 128 bit.
		As you can see, even for storing 100th fibonacci number, we require more than 64 bits memory and for list in python, we require (4 * 128) 512 bits of memory to store the 100th number. That's a lot of space for finding the sum of even fibonacci numbers
		
		Eventhough, the program computes the sum faster, after the creation of array. Array will take up huge amounts of space, when n increases
		
		If speed is important than space(memory), then we can use this approach
		
	
		
		
			
			
		